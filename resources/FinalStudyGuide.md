# Final Exam Study Guide
The final exam will be an overview of all the materials covered in class for the entire semester, mostly focusing on topics from the second half of the semester and excluding guest lectures. The exam will be approximately one hour in-person and hand-written (no computers). You may **NOT** use any notes, lectures slides, and course materials or work with another person on this exam. Below is a general study guide to help organize your notes and preparation efforts. The final exam content may include but is not limited to the following:

### Software Processes
* Explain the advantages and disadvantages of iterative and plan-driven processes
* Compare, contrast, and apply different plan-driven SE processes: (V-model, Waterfall)
* Compare, contrast, and apply different iterative SE processes: (Incremental, Prototyping, Spiral)
* Code-and-fix was the "process" of the 1950s
* Compare, contrast, and apply different agile-based processes: (Scrum, Kanban, Extreme Programming, Adaptive Software Development, Crystal Agile Framework, Lean Software Development)
* Understand the differences between different types of agile-based meetings: (scrum/standup meeting, retrospective, sprint planning, triage, sprint review)
* Understand and apply basic parts of a repository

### Requirements
* Explain the difference between requirements analysis, specifiction, and elicitation
* Understand the difference between functional and non-functional requirements
* Describe how to apply requirements elicitation techniques: (surveys, interviews, focus groups/brainstorming, prototyping, ethnographies)
* Write a user story for a given scenario
* Understand the different between a use case and a user story

### Design
* Understand the difference between high-level/architectural, low-level, and UI design
* Apply architectural design patterns: (pipe-and-filter, event-based, layered, etc.)
* Understand and discuss different software design concepts (i.e., abstraction, modularity, S.O.L.I.D., etc.)
* Understand the differences between low-level design pattern families (creational, structural, and behavioral)
* Describe and apply UI design processes: (i.e., prototyping, wireframing, task flow analysis, storyboarding, etc.)
* Explain the advantages and disadvantages of using design patterns
* Understand low-level design patterns (discussed in class) and how they can improve code
* Understand and discuss UI design heuristics

### Implementation
* Explain the benefits of pair programming
* Explain the difference between feature-driven, test-driven, and behavior-driven development
* Apply and describe the difference between code metrics
* Understand the difference between static and dynamic analysis
* Differentiate between common git commands

### Testing
* Understand the difference between white box and black box testing
* Compare, contrast, and apply different types of testing strategies (unit, integration, validation, and system testing)
* Understand equivalence classes and boundary value analysis and their role in testing
* Describe approaches to reduce the number of test cases in unit testing suites

### Maintenance
* Understand the difference between types of software maintenance: (corrective, preventative, perfective, and adaptive)
* Apply common maintenance activities to given scenarios
* Explain the process and benefits of code reviews

### CI/CD and Deployment
* Explain the benefits of continuous integration
* Describe approaches to reduce the number of test cases in unit testing suites
* Compare, contrast, and apply different deployment strategies
